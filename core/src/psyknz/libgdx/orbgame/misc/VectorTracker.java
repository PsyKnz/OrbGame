package psyknz.libgdx.orbgame.misc;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.math.Vector2;

public class VectorTracker {
	
	private Array<Vector2> coords; // Array containing recorded Vector2 co-ordinates.
	
	private float distance; /* Distance recorded vectors should cover if strung together in order in game units.
	* This number can be exceeded by the last recorded co-ordinate to prevent under-estimation of fast swipes. */
	
	private float len, dst; // Placeholder variables used when processing the touch co-ordinates.
	
	/** Creates a new TouchTracker with an initial length to record.
	 * @param distance Initial distance across co-ordinates the VectorTracker should maintain. */
	public VectorTracker(float distance) {
		coords = new Array<Vector2>();	// Creates a new array to track vector co-ordinates.
		this.distance = distance;		// Sets the length the array should be.
	}
	
	/** Adds the given vector to the list of vector co-ordinates. 
	 * @param vector The vector you want added to the list of touch co-ordinates.*/
	public void addVector(Vector2 vector) {
		coords.insert(0, vector);	// Adds a new touch co-ordinate to the front of the array.
		trimToDistance();			// Ensures the length of the array doesn't exceed the current maximum length.
	}
	
	/** Adds the given x, y co-ordinate to the list of recorded touches as a vector.  
	 * @param x X co-ordinate of the touch.
	 * @param y Y co-ordinate of the touch. */
	public void addVector(float x, float y) {
		Vector2 vec = new Vector2(x, y);	// Creates a new Vector2 to represent the touch location.
		addVector(vec);						// Adds the newly created touch co-ordinate to the list of co-ordinates.
	}
	
	public void addVectorToEnd(Vector2 vector) {
		coords.add(vector);
	}
	
	/** Removes any recorded co-ordinates which extend beyond the distance this TouchTracker is tracking. */
	public void trimToDistance() {
		if(coords.size > 1) {										// Trims the length of the array only if there are more than two co-ordinates.
			len = 0;												// the current assessed length is set to 0.
			for(int i = 1; i < coords.size; i++) {					// For every co-ordinate in the array,
				if(len < distance) {								// if the current length is less than the array length,
					len += coords.get(i).dst(coords.get(i - 1));	// the distance between the current co-ordinate and the last is added to the current length.
				}
				else {										// If the current length exceeds the array length,
					coords.removeRange(i, coords.size - 1);	// then all additional co-ordinates are removed from the record,
					break;									// and the process is stopped.
				}
			}
		}
	}
	
	/** Sets a new maximum distance for the TouchTracker to record and trims the current records to length. 
	 * @param length Distance the TouchTracker should record co-ordinates over. */
	public void setDistance(float length) {
		this.distance = length;	// Sets a new length in i-game units for the array.
		trimToDistance();		// Ensures the length of the array is within the newly set maximum length.
	}
	
	/**	
	 * Function to produce an array of evenly spaced co-ordinates which follow the path generated by the string of recorded user
	 * touch inputs. Co-ordinates are interpolated in between recorded co-ordinates. 
	 * @param newCoords The array you want filled with co-ordinates. Avoids creating unnecessary variables.
	 * @param num The number of co-ordinates you want interpolated.
	 * @param distance The distance between each interpolated co-ordinate.
	 * @return Reference to the array which has just been filled with interpolated co-ordinates.
	 */
	public Array<Vector2> interpolateCoords(Array<Vector2> newCoords, int num, float distance) {
		newCoords.clear();	// Clears the Array passed to hold the interpolated coords.
		
		if(coords.size > 1 && num > 1) {	// As long as there is more than 1 touch co-ordinate recorded and more than 1 requested,
			newCoords.add(coords.first());	// the first recorded touch co-ordinate is added to the array before,
			len = 0;							// the length in units of the record currently assessed is reset to 0.
			
			for(int i = 1; i < coords.size; i++) {			// Starts processing all recorded touch co-ordinates,
				dst = coords.get(i).dst(coords.get(i - 1));	// and finds the distance between them.
				len += dst;									// As it goes it adds the distance to the currently assessed length.
				
				if(len >= newCoords.size * distance) {								// If the current length assessed along the touch co-ordinates exceeds the distance to the next point,
					Vector2 v = new Vector2(coords.get(i - 1));						// a new Vector2 is created to represent an interpolated co-ordinate.
					float alpha = (distance * newCoords.size + dst - len) / dst;	// Calculates a fraction representing the interpolated point.
					v.lerp(coords.get(i), alpha);									// Lerps the new vector by alpha so that it holds the x, y co-ordinate of the interpolated point.
					newCoords.add(v);												// Adds the interpolated point to the array.
				}
				if(newCoords.size >= num) {	// If the array reaches the target number of interpolated co-ordinates,
					return newCoords;		// it is returned to stop the function processing any further.
				}
			}
			while(newCoords.size < num) {		// As long as the array hasn't been filled,
				newCoords.add(coords.peek());	// the last recorded co-ordinate is added to the array to bulk it out.
			}
		}
		else if(coords.size > 0 && num > 0) {	// If there is only 1 recorded co-ordinate, or only one is requested,
			newCoords.add(coords.first());		// the first touch co-ordinate is added to the array.
		}		
		else return null;	// If less than one co-ordinate is recorded or the user requests less than one, null is returned.
		return newCoords;	// If not already returned, the filled array is returned.
	}
	
	/**
	 * @return The array containing all recorded vectors.
	 */
	public Array<Vector2> getVectors() {
		return coords;
	}
}
