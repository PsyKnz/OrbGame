package psyknz.libgdx.orbgame;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.math.Vector2;

public class TouchTracker {
	
	private Array<Vector2> touchCoords; // Array containing recorded touch co-ordinates.	
	
	/* Total distance recorded touch co-ordinates should cover if strung together in order in game units. This number can be exceeded
	 *  by the last recorded co-ordinate to prevent under-estimation of fast swipes. */
	private float length;
	
	private float len, dst; // Placeholder variables used when processing the touch co-ordinates.
	
	public TouchTracker(float length) {
		touchCoords = new Array<Vector2>();	// Creates a new array to track touch co-ordinates.
		this.length = length;				// Sets the length the array should be.
	}
	
	// Adds the given vector to the list of recorded touch co-ordinates.
	public void addTouch(Vector2 touch) {
		touchCoords.insert(0, touch);	// Adds a new touch co-ordinate to the front of the array.
		trimToMaxLength();				// Ensures the length of the array doesn't exceed the current maximum length.
	}
	
	// Adds the given x, y co-ordinate to the list of recorded touch co-ordinates.
	public void addTouch(float x, float y) {
		Vector2 touch = new Vector2(x, y);	// Creates a new Vector2 to represent the touch location.
		addTouch(touch);					// Adds the newly created touch co-ordinate to the list of co-ordinates.
	}
	
	// Reduces the length of the touch co-ordinate array to less than or equal to the maximum length in units.
	public void trimToMaxLength() {
		if(touchCoords.size > 1) {											// Trims the length of the array only if there are more than two co-ordinates.
			len = 0;														// the current assessed length is set to 0.
			for(int i = 1; i < touchCoords.size; i++) {						// For every co-ordinate in the array,
				if(len < length) {											// if the current length is less than the array length,
					len += touchCoords.get(i).dst(touchCoords.get(i - 1));	// the distance between the current co-ordinate and the last is added to the current length.
				}
				else {													// If the current length exceeds the array length,
					touchCoords.removeRange(i, touchCoords.size - 1);	// then all additional co-ordinates are removed from the record,
					break;												// and the process is stopped.
				}
			}
		}
	}
	
	// Sets a new maximum length for the TouchTracker.
	public void setMaxLength(float length) {
		this.length = length;	// Sets a new length in i-game units for the array.
		trimToMaxLength();		// Ensures the length of the array is within the newly set maximum length.
	}
	
	/**	Function to produce an array of evenly spaced co-ordinates which follow the path generated by the string of recorded user
	 *  touch inputs. Co-ordinates are interpolated in between recorded co-ordinates. 
	 * @param coords The array you want filled with co-ordinates. Avoids creating unnecessary variables.
	 * @param num The number of co-ordinates you want interpolated.
	 * @param distance The distance between each interpolated co-ordinate.
	 * @return Reference to the array which has just been filled with interpolated co-ordinates. */
	public Array<Vector2> interpolateCoords(Array<Vector2> coords, int num, float distance) {
		coords.clear();	// Clears the Array passed to hold the interpolated coords.
		
		if(touchCoords.size > 1 && num > 1) {	// As long as there is more than 1 touch co-ordinate recorded and more than 1 requested,
			coords.add(touchCoords.first());	// the first recorded touch co-ordinate is added to the array before,
			len = 0;							// the length in units of the record currently assessed is reset to 0.
			
			for(int i = 1; i < touchCoords.size; i++) {					// Starts processing all recorded touch co-ordinates,
				dst = touchCoords.get(i).dst(touchCoords.get(i - 1));	// and finds the distance between them.
				len += dst;												// As it goes it adds the distance to the currently assessed length.
				
				if(len >= coords.size * distance) {								// If the current length assessed along the touch co-ordinates exceeds the distance to the next point,
					Vector2 v = new Vector2(touchCoords.get(i - 1));			// a new Vector2 is created to represent an interpolated co-ordinate.
					float alpha = (distance * coords.size + dst - len) / dst;	// Calculates a fraction representing the interpolated point.
					v.lerp(touchCoords.get(i), alpha);							// Lerps the new vector by alpha so that it holds the x, y co-ordinate of the interpolated point.
					coords.add(v);												// Adds the interpolated point to the array.
				}
				if(coords.size >= num) {	// If the array reaches the target number of interpolated co-ordinates,
					return coords;			// it is returned to stop the function processing any further.
				}
			}
			while(coords.size < num) {			// As long as the array hasn't been filled,
				coords.add(touchCoords.peek());	// the last recorded co-ordinate is added to the array to bulk it out.
			}
		}
		else if(touchCoords.size > 0 && num > 0) {	// If there is only 1 recorded co-ordinate, or only one is requested,
			coords.add(touchCoords.first());		// the first touch co-ordinate is added to the array.
		}		
		else return null;	// If less than one co-ordinate is recorded or the user requests less than one, null is returned.
		return coords;		// If not already returned, the filled array is returned.
	}
}
